# Chapter 4. fold

プログラムを非常に大雑把に見ると、ある対象に対して次々と操作を加えていく、というものとして考えることができます。

例えば、テトリスを考えてみましょう。<br>
プレイヤーが下ボタンを押すと、画面にあるブロックを下に移動する → 画面にあるブロックが並んだらそれらを消す → 画面にある
スコアの数字に変化を加える、というように、プレイヤーの入力に対して画面上に変化を次々に加えていく、
というように見ることができます。

一般化して考えると、初期状態 `a0` があり（テトリスの場合、プレイヤーが操作する前の画面）、
`p` という操作が加えられ `a1` という状況に変化し、さらに `q` という操作が加えられ `a2` に、
さらに `r` という操作が加えられ `a3` という状態に変化していく、ということが
プログラムの実行であると考えることができます。

このように操作が次々に加えられて初期状態に変更を加えていくことを、
関数型言語では **fold（畳み込み）** という言葉で表します。

先程の例を式で表すと、以下のように表せます。

**(A)** `(r (q (p a0))) = a3`

**(B)** `(((a0 p) q) r) = a3`

**(A)** のイメージを `foldr`（右側から作用をさせていく）、
**(B)** のイメージを `foldl`（左側から作用をさせていく）と表します。

右側からと、左側からの操作の違いは、リストの連結操作などを考えてみると分かりやすいと思います。<br>
`[3]` を連結してから `[4]` を連結する場合、
`[1, 2] ++ [3] ++ [4]` と `[4] ++ [3] ++ [1, 2]` は異なる結果となります。

## foldl
まず、`foldl` の型を見てみましょう。
```
foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
```
`t` は、`Foldable t` となっているので、畳み込みができるもの、つまり、連結操作ができるものであると考えてください。<br> 
その `t` を用いて、`t b` とありますが、正確な意味は後で理解するとして、今は `[a]` と読み替えて考えましょう。<nr>

**リスト１**
```
foldl :: (a -> b -> a) -> a -> [b] -> a
```

慣れていないと型を見ても分かりにくいと思いますが、具体例を見ると理解しやすいです。<br>
`foldl` と `show` を用いた例を見てみましょう。`show` は、与えられたものを文字列にする関数です。
```
ghci> show 1
"1"
```

`a -> b -> a` が操作を表し、`a` は初期値から操作を加えられていくもの、
`b` は操作を与える側となるもの、と考えながら以下の具体例を見てください。
```
ghci> f a b = a ++ show b
ghci> foldl f "" [1, 2, 3, 4]
"12345"
```

上の式は、型変数 `a`, `b` の役割が分かりやすいように `f` の引数として `a`, `b` を用いましたが、
以下のように書いても同じことであると確認しておいてください。<br>
**リスト２**
```
ghci> f x y = x ++ show y
ghci> foldl f "" [1, 2, 3, 4]
"12345"
```

リスト２では、初期値 `""` に `[1, 2, 3, 4]` の左端の要素から順番に `f` に適用させていく、という動作を行います。

`f "" 1 = "1"`<br>
→ `f "1" 2 = "12"`<br>
→ `f "12" 3 = "123"`<br>
→ `f "123" 4 = "1234"`

と fold されていきます。

次に型について考えてみましょう。

Haskell においては、型というのが大事な役割を担うため、リスト２における `foldl` の型の確認をしておきます。<br>
今は簡単のために、`1, 2, 3, 4, 5` を整数 `Int` 型の列であるとすると、リスト２の２つの関数の型は

`f :: String -> Int -> String`

`foldl :: (String -> Int -> String) -> String -> [Int] -> String`

となります。初期値と出力値が `String` であるということを意識すると分かりやすいと思います。<br>
Haskell では、リスト１のように型変数で指定された箇所に、具体的な型 `String` や `Int` を当てはめて型のチェックを行うので、
何の型が利用されているのか常に意識すると良いと思います。

`foldl` に慣れるために、１から１０まで足し算してみる、というのを考えてみましょう。<br>
以前にも一度、このようなものを考えましたが、`foldl` を用いると以下のように書くことができます。
```
ghci> foldl (+) 0 [1 .. 10]
55
```

Haskell では、`+` 記号を関数として扱うことができるので、上のような書き方ができます。<br>
上の場合では、`foldl` の型は

`foldl :: (Int -> Int -> Int) -> Int -> [Int] -> Int`

となります。`(+) :: Int -> Int -> Int` となっているので `Int` ばかりとなり分かりにくいですが、
型について考えてみてください。

Haskell の型チェックは、同じ型変数のところには同じ型が入るかどうか、ということを検査します。<vr>
そのため、`g x y = Show (x + Show y)`（`g :: Int -> String -> String`）のような関数は `foldl` に利用することはできません。<br>
`foldl` に利用できる関数は `a -> b -> a` の型とされているためです。
