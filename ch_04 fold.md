# Chapter 4. fold

プログラムを非常に大雑把に見ると、ある対象に対して次々と操作を加えていく、というものとして考えることができます。

例えば、テトリスを考えてみましょう。<br>
プレイヤーが下ボタンを押すと、画面にあるブロックを下に移動する → 画面にあるブロックが並んだらそれらを消す → 画面にある
スコアの数字に変化を加える、というように、プレイヤーの入力に対して画面上に変化を次々に加えていく、
というように見ることができます。

一般化して考えると、初期状態 `a0` があり（テトリスの場合、プレイヤーが操作する前の画面）、
`p` という操作が加えられ `a1` という状況に変化し、さらに `q` という操作が加えられ `a2` に、
さらに `r` という操作が加えられ `a3` という状態に変化していく、ということが
プログラムの実行であると考えることができます。

このように操作が次々に加えられて初期状態に変更を加えていくことを、
関数型言語では **fold（畳み込み）** という言葉で表します。

先程の例を式で表すと、以下のように表せます。

**(A)** `(r (q (p a0))) = a3`

**(B)** `(((a0 p) q) r) = a3`

**(A)** のイメージを `foldr`（右側に初期値がある）、
**(B)** のイメージを `foldl`（左側に初期値がある）と表します。

右側からと、左側からの操作の違いは、リストの連結操作などを考えてみると分かりやすいと思います。<br>
`[3]` を連結してから `[4]` を連結する場合、
`[1, 2] ++ [3] ++ [4]` と `[4] ++ [3] ++ [1, 2]` は異なる結果となります。

**モナド** は、次々に操作を加えていく、という概念に対して力を発揮するため、
操作を連結する fold という概念をここでよく確認しておいてください。

## foldl
`foldl` は、Haskell でよく利用される関数です。`foldl` の型を見てみましょう。
```
ghci> :t foldl
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```
`t` は、`Foldable t` となっているので、畳み込みができるもの、つまり、連結操作ができるものであると考えてください。<br> 
その `t` を用いて、`t b` とありますが、
しばらくの間は `[b]` と読み替えて問題ないので、以下のように考えてください。<br>
`Foldable` の正確な意味は、Haskell の動作に慣れてから理解すれば問題ありません。

**リスト１**
```
foldl :: (a -> b -> a) -> a -> [b] -> a
```

慣れていないと型を見ても分かりにくいと思いますが、具体例を見ると理解しやすいです。<br>
`foldl` と `show` を用いた例を見てみましょう。`show` は、与えられたものを文字列にする関数です。
```
ghci> show 1
"1"
```

`a -> b -> a` が操作を表し、`a` は初期値から操作を加えられていく側のもの、
`b` は操作を加える側となるもの、と考えながら以下の具体例を見てください。
```
ghci> f a b = a ++ show b

ghci> foldl f "p" [1, 2, 3, 4]
"p1234"
```

上の式は、型変数 `a`, `b` の役割が分かりやすいように `f` の引数として `a`, `b` を用いましたが、
以下のように書いても同じことであると理解しておいてください。

**リスト２**
```
ghci> f x y = x ++ show y

ghci> foldl f "p" [1, 2, 3, 4]
"p1234"
```

リスト２では、初期値 `"p"` に `[1, 2, 3, 4]` の **左端** の要素から順番に `f` に適用させていく、という動作を行います。

`f "p" 1 = "p1"`<br>
→ `f "p1" 2 = "p12"`<br>
→ `f "p12" 3 = "p123"`<br>
→ `f "p123" 4 = "p1234"`

と fold されていきます。

次に型について考えてみましょう。

Haskell においては、型というのが大事な役割を担うため、リスト２における `foldl` の型の確認をしておきます。<br>
`1, 2, 3, 4` を整数 `Int` 型の列であると考えると、リスト２の２つの関数の型は

`f :: String -> Int -> String`

`foldl :: (String -> Int -> String) -> String -> [Int] -> String`

となります。初期値と出力値が `String` であるということを意識すると分かりやすいと思います。<br>
Haskell では、リスト１のように型変数で指定された箇所に、具体的な型 `String` や `Int` を当てはめて型のチェックを行うので、
何の型が利用されているのか常に意識すると良いと思います。

`foldl` に慣れるために、１から１０まで足し算してみる、というのを考えてみましょう。<br>
以前にも一度、このようなものを考えましたが、`foldl` を用いると以下のように書くことができます。
```
ghci> foldl (+) 0 [1 .. 10]
55
```

Haskell では、`+` 記号を関数として扱うことができるので、上のような書き方ができます。<br>
上の場合では、`foldl` の型は

`foldl :: (Int -> Int -> Int) -> Int -> [Int] -> Int`

となります。`(+) :: Int -> Int -> Int` となっているので `Int` ばかりとなり分かりにくいですが、
「操作を加えられる側」と「操作を加える側」に注目して型について考えてみてください。

Haskell の型チェックは、「同じ型変数のところには同じ型が入るかどうか」ということを検査するシステムになっています。<br>
型チェックをパスすれば、任意の型を関数に適用させることができるという柔軟な設計になっています。

そのため、`g x y = Show (x + Show y)`（`g :: Int -> String -> String`）のような関数は `foldl` に利用することはできません。<br>
`foldl` に利用できる関数は `a -> b -> a` の型とされているためです。

> Tips<br>
> C言語などを知っていると、関数は決められた型を受け取る、というイメージが強いと思います。<br>
> Haskell の「関数の型変数」は、一般的な命令形言語では「ジェネリクス」のイメージに一致します。<br>
> もし、決まった型のみを適用させるようにしたい場合は、以下のように書けば、関数は決められた型のみが適用できるようになります。
>
> ```
> f :: Int -> Int -> Int
> f x y = x + y
> ```
> 上のようにプログラムを書くと、`x` と `y` の部分には `Int` 型の整数のみを適用させることができるようになり、
> `f 1.5 2.5` とした場合にエラーを出力させるようにすることができます。

## foldr
次に、`foldr` についても触れておきます。`foldl` と動作は同じで、右側から作用をさせていく関数となります。<br>
`foldr` の型は `foldl` とほぼ同じで、以下のようになります。
```
ghci> :t foldr
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
```

`foldl` と同じように、今の段階では以下のように考えておきましょう。
```
foldr :: (a -> b -> b) -> b -> [a] -> b
```

`foldr` は、`(操作を加える側) (操作を加えられる側)` という位置関係になるため、
操作を行う関数の型が `a -> b -> b` となります。<br>
（`foldl` では `(操作を加えられる側) (操作を加える側)` という位置関係になります。）<br>
先述した **(A)** を見てみると分かりやすいと思います。

また、`foldl` と比べると、`a` と `b` の位置が入れ替わったように見えますが、
`foldr` の型の表示は、初期値が `b` で、操作を加える側の型が `a` になっていると考えると、
`foldl` と意味は同じであると分かると思います。

`foldr` を実際に使ってみると、以下のようになります。

**リスト３**
```
ghci> f x y = show x ++ y

ghci> foldr f "p" [1, 2, 3, 4]
"1234p"
```
リスト３では、初期値 `"p"` に `[1, 2, 3, 4]` の **右端** の要素から順番に `f` に適用させていく、という動作を行います。<br>
もう一度、**(A)** を見てみると、右端の要素から操作が加えられるイメージが伝わると思います。

`foldl` のときとの違いは２つあります。

(1) `f` の定義が `show x ++ y` に変わった。

(2) 結果の文字列の `p` の位置が変わった。

上の２つのことは、`foldr` の `(操作を加える側) (操作を加えられる側)` という位置関係を考えると理解しやすいです。

`f 4 "p" = "4p"`（`f 4 "p" = show 4 ++ "p" = "4p"`）<br>
→ `f 3 "4p" = "34p"`<br>
→ `f 2 "34p" = "234p"`<br>
→ `f 1 "234p" = "1234p"`<br>

このように、評価値が列になるようなものの場合、`foldl` と `foldr` に違いが表れます。<br>
操作を右から加えるか、左から加えるかに違いがない場合は、`foldl` と `foldr` の評価値は同じものになります。

例えば、数値の足し算であれば、`a + b` と `b + a` の結果は同じものになるため、
`foldl` と `foldr` の評価値は同じものになります。

```
ghci> foldr (+) 0 [1 .. 10]
55
```

