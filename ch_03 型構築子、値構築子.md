# Chapter 3. 型構築子、値構築子

## 型構築子（型コンストラクタ）
Haskell では `data` というキーワードを用いて新しい「型」を作ることができます。<br>
```Haskell
-- 本の ID、書籍名、著者名（複数人）の情報を持つデータをイメージしています。
data BookInfo = Book Int String [String]
```

`data` に続く `BookInfo` は「型」の名前を表し、**型構築子（型コンストラクタ）** と呼ばれます。<br>

その後の `Book` は **値構築子（値コンストラクタ）** と呼ばれ、`Book` という識別子で `BookInfo` 型として利用できるデータを作る、という意味になります。<br>
`Book` に続く `Int String [String]` は、`Book` が持つデータは `Int` と `String` と `[String]` の３つとなる、という意味になります。<br>

以下のようにすると、具体的な値を作ることができます。
```Haskell
book1 = Book 1 "Kids Science" ["Mike", "Bob"]  -- イメージとしては、本の ID、書籍名、複数の著者名
```
これで、`book1` は `BookInfo` 型の値で、上記の３つのデータを持つものとして利用できるようになります。

## 値構築子（値コンストラクタ）
Haskell は、以下のように「１つの型」で複数のデータ構造を持つことができます。<br>
`|` は、一般的な言語と同様に「or」の意味を表すものと考えてください。

```Haskell
data BookInfo = Book Int String [String]
              | BookPrice Int String Int  -- 本の ID、書籍名、価格をイメージしています。
```

上のようにすると、`BookInfo` という型は２種類のデータ構造を持つものとなり、
以下のように、２種類の方法で `BookInfo` の値を作ることができるようになります。
```
book1 = Book 1 "Kids Science" ["Mike", "Bob"]
book2 = BookPrice 2 "Kids Math" 500
```

`BookInfo` 型に `BookPrice` のような値構築子を追加した場合、その型の値は、著者名のデータを持たない場合もある、
というような注意が必要となります。<br>

Haskell では、このような複数の値構築子を持つことの方が普通であり、さらに、複数ある値構築子は
条件分岐の道具として利用されることが多い、ということを念頭においておくと良いと思います。<br>
Haskell では、条件分岐をさせるために複数の値構築子を準備する、
というスタイルをとることがよくあります。

> Tips<br>
> Haskell の「型」は、一般的なプログラミング言語では、discriminated union とイメージが一致します。

## レコード構文
先程は、初歩の例として値構築子の使い方を説明しましたが、
値構築子は以下のような **レコード構文** を用いてを記述することの方が一般的です。

```Haskell
data BookInfo = Book {
   bookID :: Int,  -- フィールド名 :: 型 の順序で記述します。
   bookTitle :: String,
   bookAuthors :: [String]
}
```

レコード構文を用いると、次のように値を生成することができます。
```Haskell
-- レコード構文を用いて書くと、それぞれの値の意味が分かりやすい。
myBook1 = Book { bookID = 1, bookTitle = "Science", bookAuthors = ["John"] }

-- もちろん、レコード構文を用いずに書くこともできます。
myBook2 = Book 2 "Pure Code" ["Mike", "Bob"]
```

レコード構文に付けた各フィールド名は、**値を取り出す「関数」** としても利用できるようになります。<br>
上の方で定義した `bookID` や、`bookTitle` は **関数** として利用できます。

```Haskell
ghci> bookTitle myBook1
"Science"

ghci> bookID myBook1
1
```

`bookID` は関数であるので、その型をとることができます。
```
ghci> :t bookTitle
bookTitle :: BookInfo -> String  -- BookInfo から、文字列を評価値として生み出す関数と認識されています。
```

## 値構築子で条件分岐をさせる例
以下のような平面上の座標を表す型を考えてみます。<br>
`Polar` は極座標を表すものと考えてください。（`r` が原点からの距離、`t` が偏角を表しています。）

```Haskell
data Point2D
    = XY { x :: Double, y :: Double }
    | Polar { r :: Double, t :: Double }
    deriving Show
```
`deriving Show` といのは、`Point2D` の型を表示できるようにするものです。今は特に気にしないでください。

極座標を与えられた場合、それを `XY` 形式に変換する関数は以下のように書けます。
```Haskell
transXY (Polar r t) = XY (r * cos t) (r * sin t)
```

`=` が書き換えのルールを表している、という感覚が伝わると思います。<br>
C言語のような代入の意味の `=` とは感覚が異なります。

上の２つを ghci に読み込ませると、以下のように操作ができるようになります。
```
ghci> p = Polar 1 (pi/4)

ghci> transXY p
XY {x = 0.7071067811865476, y = 0.7071067811865475} 
```
