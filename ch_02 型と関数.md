# Chapter 2. 型と関数

Chapter 1 で「型」について少し扱ったが、Haskell はプログラム内で扱うものすべてに「型」という情報を持たせている。<br>
「型」は主に「エラーの顕在化」に利用される。大雑把に言えば、エラーが無ければ「型」という概念は必要ない。<br>
普段の生活においては、`'a'` と `"abc"` が異なる「型」である、などと考える必要はないが、まったくエラーがないプログラムを書くことは難しいため、「型」という情報を持たせて、エラーを発見しやすいようにしている。<br>

自分が扱っている型を「明示したい」と思う場合、以下のように `::` を用いて意思表示をすることができる。
```
ghci> 'a' :: Char  --「'a' を Char型 であると考えている」と明示している
'a'

ghci> [1,2,3] :: [Int]  --「[1,2,3] を Int型（整数型）のリストと考えている」と明示している
[1,2,3]
```

上で「Int」型という「型」が出てきたが、コンピュータ内での処理の効率を上げるため、数値に対してもいくつかの型が用意されている。
```
ghci> :set +t
ghci> 1 + 2 :: Int  -- 数値を「Int（整数）」型で処理
3
it :: Int

ghci> 1 + 2 :: Double  -- 数値を「Double（倍精度浮動小数点型）」で処理
3.0  -- 小数点型で計算をした、と意思表示をしたため、計算結果が 3.0 と小数点表記となる
it :: Double

ghci> 1 + 2 :: Char  -- 数値は「Char」型では処理できないため、エラーとなる
エラーが表示される

ghci> x = [1,2,3] :: [Int]
ghci> y = [4, 5] :: [Int]

ghci> x ++ y -- x も y も同じ [Int] 同士であるため連結できる
[1,2,3,4,5]

ghci> z = [4,5] :: [Double]
ghci> x ++ z -- z は [Double] として定義されているため、x と連結できない
エラーが表示される
```

> Tips<br>
> `Int` は整数のみを扱う場合に利用するもので、処理速度が速い。<br>
> `Double` は小数も扱う場合に利用するもので、処理速度が `Int` よりほんの少し遅い。
>
> `Int` は整数（Integer）の略であり、`Double` は倍精度浮動小数点数という言葉が由来となっている。<br>

## 関数
関数に何かを適用させるとき、関数の後ろに適用させるものを書けばよい。<br>
`odd` 関数は「奇数であるかどうかを判定する関数」で、以下のようになる。
```
ghci> odd 3
True

ghci> odd 6
False
```
* 引数を２つ以上とる関数の場合、引数を並べて書けば良い。

例： `compare` 関数は、２つのものの大小関係を判定する。「１つ目のもの」が大きいか小さいかを返す。
```
ghci> compare 2 3  -- LT は小さいという意味
LT

ghci> compare 3 3  -- EQ は等しいという意味
EQ

ghci> compare 3 2  -- GT は大きいという意味
GT
```
以下のような使い方もできる。
```
ghci> (compare 2 3) == LT
True

ghci> compare 2 3 == LT
True

ghci> compare (sqrt 3) (sqrt 6)  -- sqrt は平方根を求める関数
LT
```

例：３つの数を受け取って、その和を返す関数を作って、使ってみよう
```
ghci> f x y z = x + y + z  -- これで f(x,y,z) = x + y + z という関数が定義できた

ghci> f 2 3 4  -- f(2,3,4) を計算する
9
```

---
* 重要：Haskell では、「関数への適用」の優先度が最も高い<br>
以下の２つは同じ意味。Haskell では、読みやすくするために **「かっこを省いて書く」** ことが多くなる。<br>
**「関数への適用の優先度が高い」** という意識を常に持っておかないと、式を間違って読んでしまいがちになるので、このことを頭の隅においておいてほしい。<bu>
```
ghci> 2 + (max 10 20) * 3 + 5
67

ghci> 2 + max 10 20 * 3 + 5
67
```

* 「if」も式<br>
Haskell は、関数型言語であり、原則として何かを受け取って、何かを返す、という処理を続けていく。<br>
そのため、`if` を利用する場合、`else` は省略できない。

```
ghci> f x = if x > 10 then "x is > 10" else "x is <= 10"
ghci> f 8
"x is <= 10"
```

## リストを操作する関数
リストの最初の要素を返す関数の `head`。
```
ghci> head [1,2,3,4]
1

ghci> head ['a','b','c']
'a'
```
リストの最初の要素を除いた「残りの要素」を返す関数の `tail`。
```
ghci> tail [1,2,3,4]
[2,3,4]

ghci> tail [2,3,4]
[3,4]

ghci> tail [True,False,True]
[False,True]

ghci> tail "list"
"ist"

ghci> tail []  -- 空リストは、最初の要素がないためエラーとなる。
エラーが表示される
```
「リストのリスト」の使用例
```
ghci> :type [['a','b', 'c'],['d']]
[['a','b', 'c'],['d']] :: [[Char]]
```
> Tips<br>
> 型名は大文字始まりで、変数名は小文字始まりで書くのが慣例となっている。


リストの最初のいくつかの要素を「リストとして返す」関数
```
ghci> take 1 [1,2,3,4,5]
[1]

ghci> take 2 [1,2,3,4,5]
[1,2]

ghci> take 3 [1,2,3,4,5]
[1,2,3]
```
リストの最初のいくつかの要素を「取り除いて」「リストとして返す」関数
```
ghci> drop 1 [1,2,3,4,5]
[2,3,4,5]

ghci> drop 2 [1,2,3,4,5]
[3,4,5]

ghci> drop 3 [1,2,3,4,5]
[4,5]
```

## タプルは () で表す。<br>
リストは１つの型の列しか扱えないが、タプルは複数の型を混ぜて使うことができる。
```
ghci> (123, "abcd")
(123,"abcd")

ghci> :type (True, "hello")
(True, "hello") :: (Bool, [Char])

ghci> (5, ['x', 'y'], (10, True))
(5,"xy",(10,True))
```
「サイズ２のタプル」に対して、１番目の要素、２番目の要素を返す関数
```
ghci> fst (1,'a')
1

ghci> snd (1,'a')
'a'

ghci> fst (1, 'a', 'b')  -- サイズが３のタプルに対してはエラーとなる
エラーが表示される
```

## 関数の型と純粋性
* 関数の型の例１<br>
関数 `lines` は、文字列を改行コード `\n` で分割してリストにして返す関数である。
```
ghci> lines "the quick\nbrown fox\njumps"
["the quick","brown fox","jumps"]
```
この `lines` の型は以下のようになる。
```
ghci> :type lines
lines :: String -> [String]
```
`String -> [String]` は、「文字列を受け取って、文字列のリストを返す関数」ということを表す。<br>

* 関数の型の例２<br>
`fst` は、以下のような関数であった。
```
ghci> fst ('x', 10)
'x'
```
`fst` は、タプルを受け取り、１番目のものを返す関数である。従って、その「型」は以下のようになる。
```
ghci> :type fst
fst :: (a, b) -> a
```
上の `a` は、型変数と言われるもので、`a` の部分にはいろいろな「型」が入ることを表している。

* 関数の型の例３<br>
先述した `take` は、「取り出す文字数」と「リスト」を受け取って、「リスト」を返す関数である。
```
ghci> :type take
take :: Int -> [a] -> [a]
```
上記の `[a]` は、現段階では「リスト」を表す、と考えておけば良い。

* 関数の純粋性<br>
原則として、Haskell の関数は pure である。pure とは、関数の出力は、引数で与えられたもののみで決定されるということを表す。<br>
同じ引数を与えた場合、「常に同じ結果が返される」ということである。<br>

関数の途中で、ユーザの入力を受け取る場合など、引数以外の要因で関数の結果が変わるということは当然ある。<br>
その場合、その関数は pure でない、と言う。<br>
引数以外の要因で関数の出力結果が変わってしまう場合、その関数の型は IO で始まるものとなる。<br>

標準入力を受け取る関数 `getLine` について見てみると、以下のようになる。
```
ghci> getLine
abcdef  --「abcdef」とキーボードから入力した
"abcdef"  -- getLine の戻り値は "abcdef" となった、ということ

ghci> getLine
ghi  --「ghi」とキーボードから入力した
"ghi"  -- getLine の戻り値は "ghi" となった、ということ
```
上記のように、「`getLine` には引数を与えていない」という同じ条件であるのに、`getLine` の返す値は変化するので、`getLine` は pure でない関数である。

`getLine` の型を見てみると、以下のようになる。
```
ghci> :type getLine
getLine :: IO String
```

## ソースファイル
以下の１行を書いたファイルを作成し、`add.hs` という名前で保存する。
```Haskell
add a b = a + b
```
> Tips<br>
> ghic で、シェルコマンドを実行する場合 `:!` を先頭に付ける。
> ```
> 例
> ghci> :!ls
> ghci> :!echo "add a b = a + b" > add.hs
> ```
> `cd` など、いくつかのコマンドは、「!」を付けなくても利用できる。

`:load` コマンドで、上記の `add.hs` を読み込むと、以下のように `add` を利用することができるようになる。
```
ghci> :load add.hs

ghci> add 2 3
5
```

## 簡単なプログラムの作成
標準関数の `drop` と同じ動作をする関数を作ってみよう。<br>
まず、`drop` の動作を確認すると以下のようになる。
```
ghci> drop 2 "abcdef"
"cdef"

ghci> drop 4 "abcdef"
"ef"

ghci> drop 4 [1,2]
[]

ghci> drop 0 [1,2]
[1,2]

ghci> drop 5 []
[]

ghci> drop (-2) "abc"
"abc"
```

以下の内容を `myDrop.hs` に保存する。
```Haskell
myDrop n xs = if n <= 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)
```
`null` は、リストが空であるかどうか判定する関数である。
```
ghci> null []
True
ghci> null [1,2,3]
False
```

> Tips<br>
> Haskell では「`if` は式」（「必ず値を返す」ということ）であるため、`else` を省略することはできない。

上記の myDrop が正しく動作するかどうかを確認する。
```
ghci> :load myDrop.hs
ghci> myDrop 2 "abcdef"
"cdef"

ghci> myDrop 4 "abcdef"
"ef"
以下略...
```

## 遅延評価
以下の例を実行してみてほしい。（適当なファイルに保存し、`:load` して、`main` を実行する。）<br>
`import Debug.Trace` は、`trace` を利用するために書いている。`trace` は、`trace A B` で、A の文字列を表示して、B を評価するという関数。<br>
`sub` 関数は、「sub を実行」を表示して、「sub の戻り値」という文字列を返す。<br>
`do` は、上から順に式を評価していくもの。<br>
`let` は、数学の「＝」と同様に、x に値を代入するようなもの。（`let` の意味については、また後で考えてみる。）<br>
`putStrLn` は、「put string line」の意味で、文字列を表示するようなもの。（これについても、また後で考えてみる。）

```Haskell
import Debug.Trace

sub = trace "sub を実行" "sub の戻り値"

main = do
  let x = sub
  let y = trace "main を実行１" (putStrLn x)
  trace "main を実行２" y
```
上の実行結果は、以下のようになる。
```
ghci> main
main を実行２
main を実行１
sub を実行
sub の戻り値
```

他のプログラム言語をまったく知らなければ問題ないが、他の C や Python のような言語を知っていると、この表示結果には違和感があるはず。<br>
`let x = sub` のところで、sub が実行されて、その結果が `x` に代入される、と考えるのが普通であると思う。<br>
`main` の上から２行目のところで `sub` が実行され、「sub を実行」が表示され、その次の３行目で「main を実行１」が表示される、と考えるのが普通の考えであると思う。

> Tips<br>
> Haskell では、式の最後にある「値」が、その評価結果となる。<br>
> `trace "sub を実行" "sub の戻り値"` の評価結果は `"sub の戻り値"` という文字列となる。

Haskell は **遅延評価** という考えを持っている。<br>
それは、必要になるまで式の評価（式の実行）は行わない、という意味である。<br>
`let x = sub` という行では、`x` の値がどういう値であってもプログラムの実行は次に進められるので、この行では `x` の値がなんであるかは求めない。`putStrLn x` が評価され、実際に表示がされるときに `x` の値が必要となるため、そのときに `sub` の内容が実行される。これが **遅延評価** の考え方である。

そういう意味で、一般的な言語では `let` は「代入」と言われるのであるが、Haskell では「bind（束縛）」と言っている。`x` という記号は、`sub` の評価結果を表すものとする、と考える。（評価は必要になるまで行わない。）

同様にして、`let y =` も、`y` は `trace "main を実行１" (putStrLn x)` の評価結果を指し示す、というだけの意味になる。<br>
従って、最終行で `trace "main を実行２" y` で、`y` が返されて、`y` が実際に評価されるときに、`trace "main を実行１" (putStrLn x)` が評価される、という流れになる。<br>
以上のように考えると、実行結果が上記のようになる、と納得できる。<br>
では、いつ値の評価がされるのか（いつ関数が実行されるのか）、ということを疑問に思うのは当然であるが、これについては、もう少し Haskell の動作を知ってもらってから解説しようと思う。

さらに、もう少しだけ詳しく見てみよう。<br>
Haskell は **関数型言語** である。つまり、値を受け取り、値を返す、ということを繰り返していくだけの言語である。<br>
`ghci> main` で `main` を評価するときに `do` により上から順番に評価されていくのであるが、では、`main` の評価結果は何であろうか？<br>
`main` の評価結果は、`y` であり、`putStrLn x` である。`x` は `sub` の評価結果であるから、`main` の評価結果は `putStrLn "sub の戻り値"` となる。

`main` の評価によって、"sub の戻り値" が表示される訳ではない。<br>
`main` の評価結果は「"sub の戻り値" を出力する」であり、ghci がその結果を受け取って画面に表示しているのである。<br>

`sub` の評価結果は「文字列」であり、`main` の評価結果は「操作が指示されるだけで、評価結果はない」ということを意識すれば、以下のように **関数の型** を明示して書くことができる。

```Haskell
import Debug.Trace

sub :: String
sub = trace "sub を実行" "sub の戻り値"

main :: IO ()
main = do
  let x = sub
  let y = trace "main を実行１" (putStrLn x)
  trace "main を実行２" y
```
> Tips<br>
> Haskell は静的型付言語である。<br>
> 通常、静的型付言語は「型」をプログラマが細かく指示することが多い。しかし、上の例で見たように、Haskell はコンパイラが「型」を推論してくれるので、「型」を書かなくて良い場合が多い。これは Haskell の１つの特徴となっている。
