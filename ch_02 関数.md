# Chapter 2. 関数

関数に何かを適用させたいときは、関数の後ろに適用させたいものを書きます。<br>
`odd` 関数は「奇数であるかどうかを判定する関数」で、以下のようになります。
```
ghci> odd 3
True

ghci> odd 6
False
```

引数を２つ以上とる関数の場合、引数を並べて書きます。<br>
`compare` 関数は、２つのものの大小関係を判定する関数で、「１つ目のもの」が大きいか小さいかを返します。
```
ghci> compare 2 3
LT  -- LT は小さいという意味

ghci> compare 3 3
EQ  -- EQ は等しいという意味

ghci> compare 3 2
GT  -- GT は大きいという意味
```

以下のような使い方もできます。
```
ghci> (compare 2 3) == LT
True

ghci> compare 4 3 == LT
False
```

Haskell では、「関数に値を適用をする」という操作を多く実行するため、その優先度が最も高くなっています。<br>
そのため、関数に値を適用する場合にかっこを省略して書くことが多く、慣れてないと式の意味を捉え間違えやすいので注意が必要です。

以下の式の結果に注目してください。`max a b` は、大きい方の値を返す関数です。掛け算があると、掛け算を先にしたくなるのですが、`max` への適応が先に実行されることに注意してください。
```
ghci> 2 + max 10 5 * 3 + 4
36
```

上の式は `2 + (max 10 5) * 3 + 4` と同じ意味になります。

## 関数の作成
３つの数を受け取って、その和を **評価値** とする関数は以下のようになります。
```
ghci> f x y z = x + y + z  -- これで f(x,y,z) = x + y + z という関数が定義できます。

ghci> f 2 3 4  -- f(2,3,4) の評価値を算出します。
9
```

ここで、「評価値」と強調している理由は現段階では伝わりにくいと思います。<br>
Haskell では、`f 2 3 4` というものを見つけたら、それは `2 + 3 + 4` と **置き換える** ものだ、というような考えで処理を進めます。<br>
数学などを通して `=` には、代入という意識が働きやすいですが、Haskell では「代入」ではなく、「置き換え」と考えます。

今、このことを強調してもその理由が分かりにくいと思いますので、今のところは `=` は置き換えなんだな、と思ってもらえばよいです。

> Tips<br>
> C言語などを利用していると、関数を定義し、その関数をコールして、関数からリターンして処理を進める、という気持ちが
> 強いと思います。<br>
> しかし、Haskell では、式の置き換えと簡約によって処理を進めていくので、C言語でいうところのリターンというものはありません。<br>
> `return` という式はありますが、C言語などとまったく異なる意味となっています。<br>
> この根本的な違いが、C言語などを知っている人が Haskell などの関数型言語を理解しにくい、という原因になっていると思います。<br>
> とりあえず、`=` は代入ではないし、関数を呼び出すものではないし、リターンなんかもないんだな、と思いながら気軽に読み進めてもらえばよいと思います。

## if も式
Haskell は関数型言語であり、**値を与えて評価値を算出する** というチェーンで処理を行います。<br>
関数は **評価値を算出し**、その評価値を次の操作に利用する、というチェーンにより処理を進めます。

そのため、結果となる評価値が必ず必要となるので、`if` も式となり、`else` も省略もできません。

```
ghci> f x = if x > 10 then "x is > 10" else "x is <= 10"

ghci> f 8
"x is <= 10"
```

> Tips<br>
> C言語などのように、if で条件が成立しなければ次の行へ進む、のようなことは関数型言語ではできません。<br>
> 慣れるまで煩わしく感じると思いますが、必ず評価値が必要となります。

## タプル

リストは１つの型の列しか扱えません。そのため、複数の型をまとめて１つとして扱う場合、タプルというものを利用します。<br>
タプルは、丸かっこ `()` を用いて表します。

```
ghci> (123, "abcd")
(123,"abcd")

ghci> :type (True, "hello")
(True, "hello") :: (Bool, [Char])

ghci> (5, ['x', 'y'], (10, True))
(5,"xy",(10,True))
```

`fst` は、「サイズ２のタプル」に対して、１番目の値を評価値とする関数です。
同様に `scd` は、２番目の値を評価値とする関数です。
```
ghci> fst (1,'a')
1

ghci> snd (1,'a')
'a'

ghci> fst (1, 'a', 'b')  -- サイズが３のタプルに対してはエラーとなります。
エラーが表示されます。
```

## 関数の型

* **例１**<br>
関数 `lines` は、文字列を `\n`（改行コード）で分割したものを評価値とする関数です。
```
ghci> lines "abc\ndef ghi\njklm"
["abc","def ghi","jklm"]
```

この `lines` の型は以下のようになります。
```
ghci> :type lines
lines :: String -> [String]
```
`String -> [String]` は、「文字列から、文字列のリストを生成する関数」
（丁寧にいうと、文字列のリストという評価値を算出する関数）ということを表します。<br>

* **例２**<br>
`fst` は、以下のような関数でした。
```
ghci> fst ("abc", 123)
"abc" 

ghci> fst (10, True)
10
```

`fst` は、タプルの１番目の値を評価値とする関数です。そのような「型」は以下のように表します。
```
ghci> :type fst
fst :: (a, b) -> a
```
タプルの１番目の値の型は、`String` になるとか `Int` になるとかなどと決まっていません。また、１番目の値の型と、２番めの値の型は異なっていても構いません。そのため、上のように `a` や `b` という文字を使って形式的に表します。<br>
決まってない型を形式的に `a` などと表す場合、`a` を型変数といいます。<br>

* **例３**<br>
`take` は、「取り出す個数」と「リスト」を受け取って、「リスト」を評価値とする関数で、以下のような動作をします。
```
ghci> take 2 [1,2,3,4,5]
[1,2]

ghci> take 3 ["abcd", "ef", "ghi", "jklm"]
["abcd","ef","ghi"]
```

この場合の関数の型は以下のようになります。
```
ghci> :type take
take :: Int -> [a] -> [a]
```
リストに含まれる値の型は `Int` や `String` など任意のものでよいので、`[a]` と表されます。

## 値の不変性

Haskell では、原則として `=` は置き換えのルールを示すものであり、代入の意味ではない、と先述しました。<br>
その意味で、一度設定したルールを変更することはできません。そのため、以下のようなプログラムは実行できません。
```
x = 1
x = 2
```

最初に `x` は `1` と置き換えられる、としているため、その次で `x = 2` とするようなルールの変更はできません。<br>
数学などでの感覚では、`x` には自由に値を代入できるというのが自然ですが、Haskell では `=` の意味が異なるため注意が必要です。

```
x = [1, 2, 3]
y = [4, 5]
```
上のように、`x` と `y` を定めると、`x` はいつでも `[1, 2, 3]` と置き換えることができ、`y` はいつでも `[4, 5]` と
置き換えることができるようになります。<br>
プログラム中のどこであっても記号の意味が変わらない、ということは Haskell の特徴であり、それによってプログラムの
安全性を高めています。Haskell では、「メモリ内に構築された値は不変である」ということを常に頭の片隅においておくと良いでしょう。

一度定めた記号の意味を変えないことは、プログラム中のバグを減らすことに大いに貢献しますが、
しかし、繰り返す動作（ループ）を実行させるときには少し手間が掛かります。

例えば、「１から `n` までの数を足し合わせる関数 `f n`」というプログラムを作ってみると、以下のようになります。

**リスト１**
```Haskell
f 1 = 1
f n = n + f (n - 1)
```

上のプログラムを読み込むと、以下のように値を求めることができるようになります。
```
ghci> f 10
55
```

Haskell は、`=` で設定されたルール順に、書き換えを実行して評価値を求めていきます。
実行は以下のように進められます。

`f 10` を求める場合、`f 1` と一致しないため `f n` を用いて書き換えます。<br>
`f 10 = 10 + f 9` となるので、`10` と `+` をメモリに書き込み、次に `f 9` を同様に処理していきます。<br>
`f 9 = 9 + f 8` により `9` と `+` を書き込み `f 8` を求める、ということを続けていき、最終的に `f 1` にたどり着きます。

`f 1 = 1` となっているため、ここで評価のチェーンが終了し、直前に `2` と `+` と書き込んでいたところに戻り、`3` という値を得ます。<br>
さらにその前に `3` と `+` をメモリに書き残していたはずなので、直前で得た `3` と合わせて `6` という評価値を得ます。<br>
以降、これを繰り返して `f 10 = 55` という評価値を最終的に得ます。

Haskell はメモリに計算手順をどんどんためこんでいき、評価のチェーンが終了したところで、チェーンにたまっている計算を実行し最終的な評価値を得ます。

> Tips<br>
> 計算手順が書き込まれたメモリの部分をサンクと言います。<br>
> 単純なループによる計算であっても、ループの回数が非常に大きい場合、サンクで大量のメモリが消費されるので注意が必要です。<br>
> 実際にどのように計算されているか関心があれば、ラムダ計算という言葉について調べると、Haskell の実際の動作を想像できて
> 面白いと思います。

また、`=` で設定されたルールは、設定された順序で実行されるので、以下のように書くとプログラムは正しく実行できません。
```Haskell
f n = n + f (n - 1)
f 1 = 1
```

上のようなプログラムで `f 10` を入力すると、計算結果はいつまで経っても求められません。<br>
`f 1 = 1 + f 0`、`f 0 = 0 + f (-1)`、、、と、どこまでも式の書き換えがメモリに書き込まれ続けます。最終的にメモリ不足になってプログラムがエラーとなり終了することになります。<br>

プログラムが止まらなくなってしまった場合には、「Ctrl + C」を入力して実行を中断させましょう。

---
**リスト１** を実行したい場合、以下のようにしてください。<br>
* step１
適当な名前のファイルを作り（ここでは、`Test.hs` としておきます）リスト１の２行を書き込んで保存してください。<br>

> Tips<br>
> (1) ghci から抜けたいときは、「Ctrl + D」を入力してください。<br>
> (2) `:!` を用いると、シェルのコマンドを使えます。<br>
>
> bash や docker の操作に慣れていない人は、以下のようにして `Test.hs` のファイルを作ると良いと思います。<br>
> ```
> ghci> :! echo "f 1 = 1" > Test.hs
> ghci> :! echo "f n = n + f (n - 1)" >> Test.hs
> ```

* step２
`Test.hs` を `:load`コマンド（省略形は `:l`）を用いて ghci に読み込んでください。
```
ghci> :l Test.hs
```

* step３
関数 `f` を実行してみてください。
```
ghci> f 10
55
```

> Tips<br>
> C言語などを知っている人であれば、リスト１のプログラムは `for` ループを用いて簡単に書けてしまうと思います。<br>
> Haskell は純粋関数型言語であるため、`i = i + 1` のような **値を書き換える操作** ができません。<br>
> そのため、関数型言語で実行効率を優先する場合は、F# などの関数型言語を使うことになると思います。（F# などでは C言語のような `for` ループを利用できます。）<br>
> 必要に応じて純粋でない関数型言語を利用することは大変良いことであると思いますが、
> まずは純粋な関数型言語に慣れておいた方が、関数型言語の意義が分かりやすいため、まずは Haskell に慣れることをおすすめします。

