https://zenn.dev/toyboot4e/books/seriously-haskell
https://zenn.dev/toyboot4e/books/seriously-haskell/viewer/1-2-abs

# 例１
標準入力から入力された２つの整数の和が、偶数になるか奇数になるか表示しよう。入力は "10 25" のように、２つの数字の間にスペースを入れたものとする。

```
（例）
入力：10 25
出力：Odd
```

```Haskell
main = do
  [a, b] <- map read . words <$> getLine
  let result = if odd (a + b) then "Odd" else "Even"
  putStrLn result
```

上のコードで重要になるのは `map read . words` となる。Haskell では、関数の適用が最も優先順位が高くなるため、`(map read) . words` と読むことになる。<br>
以下のようになることに留意するとよいと思う。

```
ghci> :t (map read) . words
(map read) . words :: Read b => String -> [b]
```

# 例２
標準入力から 1 か 0 の文字列が入力される。このとき、1 が入力された文字数を表示しよう。

```
（例）
入力：001101011
出力：5
```

```Haskell
import Data.Char

main = sum . (map digitToInt) <$> getLine
```

# 例３
標準入力から複数個（N 個としよう）の正整数が入力される。それらの正整数の全てが「２」で割れる場合、すべての整数を２で割って、新しく N 個の整数を作る。この操作を何回繰り返すことができるかを求めてみよう。

```
（例）
入力： 4 8 16
出力： 2

入力： 4 8 5
出力： 0
```

```Haskell
import Data.Bits

divCnt :: Int -> Int
divCnt num
    | num <= 0 = error "Input must be a positive integer"
    | otherwise = f 0 num
  where
    f :: Int -> Int -> Int
    f cnt num
      | (num .&. 1) > 0 = cnt
      | otherwise = f (cnt + 1) (shiftR num 1)

main = do
  inputs :: [Int] <- map read . words <$> getLine
  let cnts = map divCnt inputs
  print $ minimum cnts

```
