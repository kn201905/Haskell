# リストの操作

## リストの内包表記

Hakell のリストでは、数学の集合と同様の書き方ができる。
```
ghci>  [x * 2  | x  <-  [ 1 .. 10 ]]  
[2,4,6,8,10,12,14,16,18,20]
```
`<-` は、リストの中から要素を順番に取り出すことを表す。

条件は複数与えることもできる。
```
ghci> [x * 2  | x  <-  [ 1 .. 10 ], x <= 5]
[2,4,6,8,10]

ghci> [x * 2  | x  <-  [ 1 .. 10 ], x `mod` 3 == 1]
[2,8,14,20]

ghci> [if odd x then "odd" else "even" | x <- [1 .. 5]]
["odd","even","odd","even","odd"] 
```

また、複数の変数を扱うこともできる。
```
ghci> [x + y | x <- [1, 2, 3], y <- [50, 60, 70, 80]]
[51,61,71,81,52,62,72,82,53,63,73,83]

ghci> [x + y | x <- [1, 2, 3], y <- [50, 60, 70, 80], odd (x + y)]
[51,61,71,81,53,63,73,83]
```

アルファベットの大文字のみを取り出す関数を作ってみよう。
```
ghci> takeCapital cs = [ c | c <- cs, c `elem` ['A'..'Z']]
ghci> takeCapital "Tokyo Japan"
"TJ"
```

## リストに関して、よく利用する関数

Haskell では、リストの操作が大変重要となる。読むのも面倒であると思うが、よく利用する関数を一通り並べておく。

* `length :: [a] -> Int`  
リストの要素数を返す。

* `null :: [a] -> Bool`  
リストが空であるかどうかを返す。

* `head :: [a] -> a`  
リストの先頭の要素を返す。

* `last :: [a] -> a`  
リストの最後の要素を返す。

* `tail :: [a] -> [a]  -- 戻り値が [a] であることに注意`  
リストの先頭要素を取り除いたリストを返す。

* `init :: [a] -> [a]`  
リストの最後の要素を取り除いたリストを返す。

---
以下の２つは簡単だけど利用方法に注意すること

* `repeat :: a -> [a]`<br>
`a` を繰り返す無限の長さを持つリストを生成する。<br>
例えば、`x = repeat 1` とすると、`x` は `[1,1,1,1,...]` というリストを生成する。<br>
従って、`x` をそのまま表示しようとすると、いつまでも表示が止まらなくなるため注意が必要。<br>
先頭からいくつか取り出す、という形で利用する。
```
ghci> x = repeat 1
ghci> take 3 x
[1,1,1]
```

* `cycle :: [a] -> [a]`<br>
`repeat` と同じで、`[a]` を繰り返す無限の長さを持つリストを生成する。
```
ghci> x = cycle [1,2,3]
ghci> take 10 x
[1,2,3,1,2,3,1,2,3,1]
```

> ghci で実際に型を見てみると以下のようになる。<br>
> `cycle :: GHC.Stack.Types.HasCallStack => [a] -> [a]` <br>
> `=>` は、型クラス制約と言われるもので、これについては後で解説するので今は無視しておいてよい。

---
* `(++) :: [a] -> [a] -> [a]`  
２つのリストを結合したリストを返す。
```
ghci> [1,2] ++ [3,4,5]
[1,2,3,4,5]
```

* `concat :: [[a]] -> [a]`  
「複数のリスト」のリストを、１つのリストに変換する。
```
ghci> concat [[1,2],[3,4,5],[6,7]]
[1,2,3,4,5,6,7]
```
要するに、「複数あるリスト」を１つのリストに連結する、というイメージ。<br>
「複数あるリスト」を引数として渡すために、それらをリストとして引数で渡すので `[[a]]` というシグネチャになる。

* `reverse :: [a] -> [a]`  
リストを逆順にする。

* `and :: [Bool] -> Bool`  
`[Bool]` が全て `True` であったとき `True` を返す。<br>
ただし、空リストの場合も `True` を返すので注意すること
。
* `or :: [Bool] -> Bool`  
`[Bool]` の中で１つでも `True` があれば `True` を返す。<br>
ただし、空リストの場合、`False` を返すので注意すること。

* `all :: (a -> Bool) -> [a] -> Bool`  
関数 `a -> Bool` を `[a]` に適用して、全て `True` であれば `True` を返す。
```
ghci> all odd [1,3,5]
True

ghci> all odd [1,3,5,6]
False
```

* `any :: (a -> Bool) -> [a] -> Bool`  
関数 `a -> Bool` を `[a]` に適用して、１つ以上が `True` であれば `True` を返す。

---
* `take :: Int -> [a] -> [a]`  
`[a]` の先頭から、指定された個数を取り出す。<br>
取り出す個数分の要素がなければ、取り出せた分だけを返す。（エラーにはならない。）

* `drop :: Int -> [a] -> [a]`  
`[a]` の先頭から、指定された個数を削除する。<br>
リストの要素数が、指定された個数未満である場合、空リストが返される。（エラーにはならない。）

* `split :: Int -> [a] -> ([a], [a])`  
指定されたインデックスのところでリストを分割して、タプルとして返す。<br>
一般的なプログラミング言語と同様に、インデックスは先頭を 0 とする。
```
ghci> splitAt 0 "abcde"
("","abcde")
```

* `takeWhile :: (a -> Bool) -> [a] -> [a]`  
指定された関数で先頭から要素をチェックしていき、`True` である限り、要素を取り出し続ける。
```
ghci> takeWhile odd [1,3,5,6,7,9,10]
[1,3,5]
```

* `dropWhile :: (a -> Bool) -> [a] -> [a]`  
指定された関数で先頭から要素をチェックしていき、`True` である限り、要素を削除し続ける。
```
ghci> dropWhile odd [1,3,5,6,7,9,10]
[6,7,9,10]
```

* `break :: (a -> Bool) -> [a] -> ([a], [a])`  
指定された関数で先頭から要素をチェックしていき、`True` になったところでリストを２つに分割する。

* `span :: (a -> Bool) -> [a] -> ([a], [a])`  
指定された関数で先頭から要素をチェックしていき、`False` になったところでリストを２つに分割する。<br>
イメージとしては、「`True` である限り取り出す」ということなので、`span` という名前が付いている。

---
* `elem :: (Foldable t, Eq a) => a -> t a -> Bool`  
`Foldable t` の意味を今の段階で理解するのは難しいので、今は `t a` は `[a]` と考えよう。<br>
また、`Eq a` は、`a` は `==` によって等しいかどうか判定できるもの、という意味。<br>
`(Foldable t, Eq a) =>` は、`a` に「リストみたいなものを作ることができ」、「`==` で比較ができるものである」という
条件を付けるものとなる。このような条件を「型クラス制約」という。<br>
`a` に対して、何らかの条件を付けたくなることがあるのは自然なことであろう。<br>

今の段階では、`elem :: a -> [a] -> Bool` と思ってもらえば良い。<br>
`elem x [xs]` は、`[xs]` の中に `x` があれば `True` を返す関数となる。
```
ghci> elem 6 [2,4,6,8,10]
True
```

* `notElem :: (Foldable t, Eq a) => a -> t a -> Bool`  
`notElem :: a -> t a -> Bool` と読み替えて、`notElem x [xs]` は、`[xs]` の中に `x` がなければ `True` を返す関数となる。

---
* `map :: (a -> b) -> [a] -> [b]`  
関数 `a -> b` を、全ての `[a]` に適用し、リスト `[b]` を得る。
```
addOne :: Int -> Int
addOne x = x + 1
```
`addOne` を上のように定義すると、以下のようになる。
```
ghci> map addOne [10,11,12,13,14]
[11,12,13,14,15]
```

* `filter :: (a -> Bool) -> [a] -> [a]`  
関数 `a -> Bool` を `[a]` の要素全てに適用して、`True` となったものを全て取り出す。
```
ghci> filter odd [1,2,3,4,5]
[1,3,5]
```

* `zip :: [a] -> [b] -> [(a, b)]`  
２つのリストから、タプルのリストを生成する。<br>
生成されるタプルのリスト `[(a, b)]` の要素数は、`[a]`, `[b]` の要素数の小さい方となる。
```
ghci> zip [1,3,5,7,9] [10, 11, 12]
[(1,10),(3,11),(5,12)]
```

* `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`  
２つの引数をとる関数 `(a -> b -> c)` を受け取り、それを `[a]` と `[b]` に適用して、新しいリストを生成する。<br>
生成されるリスト `[c]` の要素数は、`[a]`, `[b]` の要素数の小さい方となる。
```
ghci> zipWith (+) [1,3,5,7,9] [10, 11, 12]
[11,14,17]
```

---
* `lines :: String -> [String]`  
文字列を改行コード `\n` で分割して、リストにして返す。<br>
`unlines` は、その逆を行う。
```
ghci> lines "123\n45678\n90"
["123","45678","90"]

ghci> unlines it
"123\n45678\n90\n"
```

* `words :: String -> [String]`  
文字列を空白文字で分割して、リストにして返す。<br>
`unwords` は、その逆を行う。
```
ghci> words "123 4567 89"
["123","4567","89"]

ghci> unwords it
"123 4567 89"
```

---
**`Data.List` モジュールをロードすると利用できる関数**
```
ghci> :module +Data.List
```

* `isPrefixOf :: Eq a => [a] -> [a] -> Bool`  
`Eq a =>` は型クラス制約であるので、今は `isPrefixOf :: [a] -> [a] -> Bool` と考えよう。<br>
１つ目に指定したリストが、２つ目のリストの先頭と一致するとき `True` を返す。
```
ghci> isPrefixOf [1,2,3] [1,2,3,4,5]
True

ghci> "Hello" `isPrefixOf` "Hello, Haskell"
True
```

* `isSuffixOf :: Eq a => [a] -> [a] -> Bool`  
１つ目に指定したリストが、２つ目のリストの末尾と一致するとき `True` を返す。
```
ghci> isSuffixOf [4,5] [1,2,3,4,5]
True

ghci> "ell" `isSuffixOf` "Hello, Haskell"
True
```

* `isInfixOf :: Eq a => [a] -> [a] -> Bool`  
１つ目に指定したリストが、２つ目のリストの一部と一致するとき `True` を返す。
```
ghci> isInfixOf [3,4,5] [1,2,3,4,5,6,7]
True

ghci> "Has" `isInfixOf` "Hello, Haskell"
True
```

* `intersperse :: a -> [a] -> [a]`<br>
リストの各要素の間に要素を割り込ませる。
```
ghci> :module + Data.List
ghci> intersperse '.' "Hello"
"H.e.l.l.o"
```

* `intercalate :: [a] -> [[a]] -> [a]`<br>
リストの各要素の間に「リスト」を割り込ませる。
```
ghci> intercalate [8,9] [[10,11,12], [20,21,22,23], [30,31]]
[10,11,12,8,9,20,21,22,23,8,9,30,31]

ghci> intercalate " and " ["ABC", "DEFGH", "IJKL"]
"ABC and DEFGH and IJKL"
```

* `transpose :: [[a]] -> [[a]]`<br>
日本でいうと高校数学の知識が必要になるが、行列において、行と列を入れ替える操作となる。
```
ghci> transpose [[1,2], [3,4],[5,6]]
[[1,3,5],[2,4,6]]
```

* `concat :: Foldable t => t [a] -> [a]`<br>
以前にも出てきたと思うが、`Foldable t => t [a]` は、`[[a]]` と考えておいてほしい。<br>
今は、`concat :: [[a]] -> [a]` と考えておくと良いと思う。<br>
リストのネストを１つ浅くする関数。ただし、１つ浅くしたとき、同じシグネチャになる必要がある。
```
ghci> concat [[1,2,3,4],[10,11]]
[1,2,3,4,10,11]

ghci> concat [["abcd","efg"],["hijklmn"]]
["abcd","efg","hijklmn"]
ghci> concat it
"abcdefghijklmn"
```
