# 逆ポーランド記法で練習
計算式を書くときに、逆ポーランド記法というのがある。<br>
逆ポーランド記法は、前から読み進めていって、演算子に出会ったときに前にある数字に演算子を適用し、その部分を数字に置き換えて計算を進めるものである。

`100 2 3 + 4 5 + * -` を計算すると以下のようになる。
```
100 2 3 +
100 5 4 5 +
100 5 9 *
100 45 -
55
```
初めて見ると分かりにくいかもしれないが、
計算の優先順位に `()` を使わずに書けることで、コンピュータで処理する場合に使いやすい表記法となっている。

`100 2 3 + 4 5 + * - = 100 - (2 + 3) * (4 + 5)` という意味になる。<br>
コンピュータにとっては、`(` に対応する `)` を探したりする必要がないため、計算しやすい方法となっている。演算子に出会ったら計算をする、ということを繰り返していけばよいのである。

この計算法を Haskell で書くと Haskell の表現法の良い練習となるため、それを書いてみよう。逆ポーランド記法のことを `RPN` というため、以下のように操作ができるようにしよう。
```
ghci> calcRPN "100 2 3 + 4 5 + * -"
55
```

まず、文字列をリストに分解してくれる `words` を使うことにする。
```
ghci> words "100 2 3 + 4 5 + * -"
["100","2","3","+","4","5","+","*","-"]
```

足し算のみできるようにすると、以下のようになる。
```Haskell
calcRPN :: (Num a, Read a) => String -> [a]
calcRPN str = foldl f [] (words str)
   where
   f (x:y:ls) "+" = (x + y):ls
   f ls str = (read str):ls
```

`foldl` の良い復習になると思う。`f` は `f "生成中のリスト（累算器）" "リストから取り出された値"` という形で適用される。<br>
`ls` はリストの意味で使っている。<br>
`x:y:[...]` と書いた場合は、`x`, `y` は要素を表すのであった。<br>
`read` は文字列を読み出して、適切な値に変換してくれる関数。

以上が分かれば、どのように実行されるかは分かると思う。

ここでもう１つ。`(Num a, Read a) =>` を消すと、コンパイルができないことを確かめておいてほしい。<br>
`x + y` としているので、`a` は `+` を適用できる型である必要がある。<br>
`read str` としているので、`a` は `read` を適用できる型である必要がある。<br>
そのため、型 `a` に `(Num a, Read a) =>` という **型クラス制約** をかけている。

非常に短いプログラムであるが、良い復習になったのではないだろうか？<br>
実際に上のプログラムを実行すると、以下のようになる。
```
ghci> calcRPN "4 5 +"
[9]  -- [] が不要であるが、これは最後に処理しよう
```

後は、`-` と `*` も同様に実装する。
```Haskell
calcRPN :: (Num a, Read a) => String -> [a]
calcRPN str = foldl f [] (words str)
   where
   f (x:y:ls) "+" = (x + y):ls
   f (x:y:ls) "-" = (y - x):ls
   f (x:y:ls) "*" = (x * y):ls
   f ls str = (read str):ls
```

上において、`-` の実装には気をつける必要がある。`foldl` でリストが生成されていくとき、数値の並びが逆順になるため、`-` の実装では `y - x` とする必要がある。`y` の方が先に生成された値であることに注意しておいてほしい。

これで、以下の結果を得ることができる。
```
ghci> calcRPN "100 2 3 + 4 5 + * -"
[55]
```

リストの先頭の要素を取り出す、と考えて、以下が１つの書き方になる。
```Haskell
calcRPN :: (Num a, Read a) => String -> a
calcRPN str = head $ foldl f [] (words str)
   where
   f (x:y:ls) "+" = (x + y):ls
   f (x:y:ls) "-" = (y - x):ls
   f (x:y:ls) "*" = (x * y):ls
   f ls str = (read str):ls
```

上記の書き方で良いのであるが、できたら関数合成 `.` を用いて以下のように書けると良いと思う。<br>
関数合成 `.` は、右結合で、**関数適用を除いて** 優先順位が最も高い、ということを意識して見てほしい。

```Haskell
calcRPN :: (Num a, Read a) => String -> a
calcRPN = head . foldl f [] . words
   where
   f (x:y:ls) "+" = x + y :ls
   f (x:y:ls) "-" = y - x :ls
   f (x:y:ls) "*" = x * y :ls
   f ls str = read str :ls
```

実行例
```
ghci> calcRPN "100 2 3 + 4 5 + * -"
55
```

