Haskell 界隈で有名な書籍「すごい Haskell たのしく学ぼう!」の無料オンライン版が以下で公開されています。<br>
http://learnyouahaskell.com/chapters

上記の本を読みやすいように要約しました。

Haskell などの関数型の言語については、**モナド** という概念が有名ですが、モナドは難しい、と世間では言われているように思います。他の言語を習得している人が、モナドとはなんだろう、と思い検索しても、圏論がどうのこうの、というような説明だったり、配列を用いた説明みたいなものがたくさんヒットしてなかなか分かりにくいと思います。

私個人の考えとしては、他のものに置き換えたような例え話をいくら聞いても理解しづらいため、少し時間は掛かりますが、実際に Haskell を使って考えるのが一番簡単だと思います。

しかし、Haskell の入門の本などを読んでいると、やはり時間が掛かります。私も上記の本を読んでモナドを理解しましたが、結構な時間が掛かってしまいました。

C 言語などを知ってる人が、モナドを理解しようと思えば、実はそれほど時間は掛かりません。モナドの概念自体は簡単です。その応用範囲が非常に広いため、いろいろな場面でモナドを適用させる方法がたくさんあって難しく感じるというわけです。

この解説では、モナドを短時間で理解し、なおかつ Haskell もある程度使えるようにする、ということに主眼を置いて解説を進めていきます。時間を節約することに主眼をおいているため、解説の仕方は淡白になりますが、重要なことは一通り理解できるようになると思います。

## インストール
docker を利用するのが一番簡単です。<br>
もし、docker を利用したことがなければ、これを機会に docker に触れてみるととても良い経験になると思います。

> **docker を使ったことがない人へ**<br>
> docker は、システムを汚さずに新しい環境を導入できる機能を持つもので、実務で開発を行う際にはほぼ必須となります。<br>
> 例えば、以下のコマンドで Haskell を導入した場合、現在利用しているシステムには何の情報も追加せずに、
> 現在利用しているシステムとは別のところに Haskell に関する全てのファイルを保存をします。<br>
> そのため、Haskell をインストールしたことにより、他のアプリケーションの動作に影響を与えたりするようなことがありません。<br>
> また、Haskell が必要なくなれば `docker rm` などのコマンドを実行することにより、Haskell に関するファイルは全て削除され、
> 何らかのゴミが残るようなことを心配する必要がありません。

```
・docker を全く使ったことがない人は、以下のコマンドを試してみてください。
docker run -it --name Haskell haskell:9

上記のコマンドを実行すると、自動的に ghci が起動し、「ghci>」というプロンプトが表示されて Haskell を利用できるようになります。

・docker を使ったことがある人は、以下のようなコマンドが良いと思います。
docker run -it -v 「現在利用しているOSと共有したいディレクトリ」:/home/shared -w /home/shared --name Haskell haskell:9 /bin/bash

上記のコマンドを実行して、bash で「ghci」とコマンドを入力すると、「ghci>」というプロンプトが表示されて Haskell を利用できるようになります。
```

# Chapter 1. 準備

## 単純な計算機としての使用例
```
ghci> 3 + (-(13 * 37))
-478

ghci> pi
3.141592653589793
```

不等号、等号の利用例。一致は「==」、不一致は「/=」を使用します。
```
ghci> 2 < 3
True

ghci> 1 == 1
True

ghci> 2 /= 3
True

ghci> 2 == 3
False
```

適当な名前の変数に値を記録しておくことにより、便利な計算機として利用できます。<br>
以下の例にあるように、`it` は直前の結果を指します。

```
ghci> a = 5 + 10
ghci> a
15

ghci> 2 * 3
6

ghci> a + it
21

ghci> b = 10
ghci> a + b
25

ghci> a + b + it
50
```

## 型
一般的なプログラム言語と同様に、コンピュータ内での処理の効率化のために、数値や文字に対して指定する「型」があります。<br>
Haskell は型を細かくチェックするため、少しだけ型について触れておきます。<br>
`:type`（省略形は `:t`）コマンドにより、型を見ることができます。

```
ghci> :type 'a'
'a' :: Char  -- 'a' の型は「Char」

ghci> :t True
True :: Bool  -- True の型は「Bool」
```

数値の型については、表示される内容の意味が現段階では分からないと思います。<br>
参考までに型を調べてみると、以下のようになります。
```
ghci> :t 1
1 :: Num a => a

ghci> :t 1.5
1.5 :: Fractional a => a
```

今の段階では、上に表示されている内容を理解することは難しいと思います。<br>
ただ、しばらくの間は、上の意味が分からなくてもまったく問題ないので安心してください。<br>
数値は数値としてうまく処理されている、とだけ分かれば十分でしょう。<br>

> Tips<br>
> 上のように `=>` で表示されているのは「型」ではなく、「型クラス制約」といわれるものになります。<br>
> `Num` は「型」ではなく、「型クラス」というものとなります。

「整数」として処理をさせるとが実行速度が速くなるため、Haskell に「整数」として処理をさせたい場合は以下のようにします。

```
ghci> a = 2 :: Int
```
上のようにすると、`a` の値は 64 bit（64 bit CPU の場合）の整数となります。続けて以下のように入力を続けてみましょう。

```
ghci> b = 3

ghci> a + b
5

ghci> :t it
it :: Int  -- a が Int 型なので、a + b の結果が Int 型で処理されているとわかります。

ghci> :t b
b :: Num a => a  -- b の型は Int になっているわけではないとわかります。
```

Haskell でよく使われる数値型は、他の一般的なプログラム言語と同様に、`Int` と `Double`（倍精度浮動小数点数）となります。他には `Integer` という桁数が無制限となっている面白い整数の型もあります。

## List
リストは、同じ型のものの列を表します。空リストは `[]` で表します。
```
ghci> [1, 2, 3]
[1,2,3]

ghci> []
[]

ghci> ["abcd", "efg", "hijk"]
["abcd","efg","hijk"]
```

異なる型を１つのリストに入れようとするとエラーとなります。
```
以下はエラーとなります。
ghci> [True, False, "testing"]
```

リストは以下のように自動生成できます。
```
ghci> [1..10]
[1,2,3,4,5,6,7,8,9,10]

ghci> [1.0,1.25..2.0]
[1.0,1.25,1.5,1.75,2.0]

ghci> [1,4..15]
[1,4,7,10,13]

ghci> [10,9..1]
[10,9,8,7,6,5,4,3,2,1]
```

リストの連結操作は `++` で行います。
```
ghci> [3,1,3] ++ [3,7]
[3,1,3,3,7]

ghci> [] ++ [False,True] ++ [True]
[False,True,True]
```

リストの先頭に要素を追加する操作は `:` で行います。
```
ghci> 1 : [2,3]
[1,2,3]

ghci> 1 : []
[1]
```

## 文字列
文字列は「"」で囲みます。
```
ghci> "This is a string."
"This is a string."
```

C言語等と同様に、エスケープシーケンスを利用することができます。
```
ghci> putStrLn "newline -->\n<-- newline"
newline -->
<-- newline
```

Haskell では、文字列は、文字のリストとして扱われます。
```
ghci> str = ['a', 'b', 'c']

ghci> str
"abc"

ghci> str == "abc"
True

ghci> :type str
str :: [Char]  -- 文字列の「型」は、Char のリスト
```

`""` は、`[]` と同じものとして扱われます。
```
ghci> "" == []
True
```

文字列はリストであるため、リストと同様の操作ができます。
```
ghci> 'a':"bc"
"abc"

ghci> "abcd" ++ "efg"
"abcdefg"
```

> Tips<br>
> 一般的なプログラム言語と同様に、Haskell では、リスト（双方向リスト）は直前のものと直後へのものへのポインタを持っている要素の集まりとなっています。<br>
> そのため、Haskell の `[Char]` 型の文字列は、かなりのメモリを消費するものとなっています。<br>
> 例えば、`"abc"` の `a`, `b`, `c` は連続したメモリ領域に格納されているのではなく、１文字１文字それぞれ双方向のポインタで結ばれています。<br>
> 文字列を効率的に操作する方法もあるので、それはまた後で紹介します。

