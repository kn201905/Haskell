# Chapter 2. 関数の型

関数に何かを適用させたいときは、関数の後ろに適用させたいものを書きます。<br>
`odd` 関数は「奇数であるかどうかを判定する関数」で、以下のようになります。
```
ghci> odd 3
True

ghci> odd 6
False
```

引数を２つ以上とる関数の場合、引数を並べて書きます。<br>
`compare` 関数は、２つのものの大小関係を判定する関数で、「１つ目のもの」が大きいか小さいかを返します。
```
ghci> compare 2 3
LT  -- LT は小さいという意味

ghci> compare 3 3
EQ  -- EQ は等しいという意味

ghci> compare 3 2
GT  -- GT は大きいという意味
```

以下のような使い方もできます。
```
ghci> (compare 2 3) == LT
True

ghci> compare 4 3 == LT
False
```

Haskell では、「関数に値を適用をする」という操作を多く実行するため、その優先度が最も高くなっています。<br>
そのため、関数に値を適用する場合にかっこを省略して書くことが多く、慣れてないと式の意味を捉え間違えやすいので注意が必要です。

以下の式の結果に注目してください。`max a b` は、大きい方の値を返す関数です。掛け算があると、掛け算を先にしたくなるのですが、`max` への適応が先に実行されることに注意してください。
```
ghci> 2 + max 10 5 * 3 + 4
36
```

上の式は `2 + (max 10 5) * 3 + 4` と同じ意味になります。

## 関数の作成
３つの数を受け取って、その和を **評価値** とする関数は以下のようになります。
```
ghci> f x y z = x + y + z  -- これで f(x,y,z) = x + y + z という関数が定義できます。

ghci> f 2 3 4  -- f(2,3,4) を計算する
9
```

ここで、「評価値」と強調している理由は現段階では伝わりにくいと思います。<br>
Haskell では、`f 2 3 4` というものを見つけたら、それは `2 + 3 + 4` と **置き換える** ものだ、というような考えで処理を進めます。<br>
数学などを通して `=` には、代入という意識が働きやすいですが、Haskell では「代入」ではなく、「置き換え」と考えます。

今、このことを強調してもその理由が分かりにくいと思いますので、今のところは `=` は置き換えなんだな、と思ってもらえばよいです。

> Tips<br>
> C言語などを利用していると、関数を定義し、その関数をコールして、関数からリターンして処理を進める、という気持ちが
> 強いと思います。<br>
> しかし、Haskell では、式の置き換えと簡約によって処理を進めていくので、C言語でいうところのリターンというものはありません。<br>
> `return` という式はありますが、C言語などとまったく異なる意味となっています。<br>
> この根本的な違いが、C言語などを知っている人が Haskell などの関数型言語を理解できない、という原因になっていると思います。<br>
> とりあえず、`=` は代入ではないし、リターンなんかもないんだな、と思いながら気軽に読み進めてもらえばよいお思います。

## if も式
Haskell は関数型言語であり、**値を与えて評価値を算出する** というチェーンで処理を行います。<br>
関数は **評価値を生み出し**、その評価値を次の操作に利用する、というチェーンにより処理を進めます。

そのため、結果となる評価値が必ず必要となるため、`if` も式となり、`else` も省略もできません。

```
ghci> f x = if x > 10 then "x is > 10" else "x is <= 10"

ghci> f 8
"x is <= 10"
```

> Tips<br>
> C言語などのように、if で条件が成立しなければ次の行へ進む、のようなことは関数型言語ではできません。<br>
> 慣れるまで煩わしく感じると思いますが、必ず評価値が必要となります。

## タプル

リストは１つの型の列しか扱えません。そのため、複数の型をまとめて１つとして扱う場合、タプルというものを利用します。<br>
タプルは、丸かっこ `()` を用いて表します。

```
ghci> (123, "abcd")
(123,"abcd")

ghci> :type (True, "hello")
(True, "hello") :: (Bool, [Char])

ghci> (5, ['x', 'y'], (10, True))
(5,"xy",(10,True))
```

`fst` は、「サイズ２のタプル」に対して、１番目の値を評価値とする関数です。
同様に `scd` は、２番目の値を評価値とする関数です。
```
ghci> fst (1,'a')
1

ghci> snd (1,'a')
'a'

ghci> fst (1, 'a', 'b')  -- サイズが３のタプルに対してはエラーとなります。
エラーが表示されます。
```

## 関数の型

* 関数の型の例１<br>
関数 `lines` は、文字列を `\n`（改行コード）で分割する関数です。
```
ghci> lines "abc\ndef ghi\njklm"
["abc","def ghi","jklm"]
```

この `lines` の型は以下のようになります。
```
ghci> :type lines
lines :: String -> [String]
```
`String -> [String]` は、「文字列から、文字列のリストを生成する関数」（丁寧にいうと、文字列のリストという評価値を生み出す関数）ということを表します。<br>

* 関数の型の例２<br>
`fst` は、以下のような関数でした。
```
ghci> fst ("abc", 123)
"abc" 

ghci> fst (10, True)
10
```

`fst` は、タプルから、その１番目の値を生成する関数である。そのような「型」は以下のように表します。
```
ghci> :type fst
fst :: (a, b) -> a
```
タプルの１番目と２番目の値の型は、`String` になるとか `Int` になるとかなどと決まっていません。そのため、上のように `a` や `b` という文字を使って形式的に表します。<br>
決まってない型を形式的に `a` などと表す場合、`a` を型変数といいます。<br>

* 関数の型の例３<br>
`take` は、「取り出す文字数」と「リスト」を受け取って、「リスト」を返す関数で、以下のような動作をします。
```
ghci> take 2 [1,2,3,4,5]
[1,2]

ghci> take 3 ["abcd", "ef", "ghi", "jklm"]
["abcd","ef","ghi"]
```

この場合の関数の型は以下のようになります。
```
ghci> :type take
take :: Int -> [a] -> [a]
```
リストに与える型は任意のものでよいので、`[a]` と表されます。


