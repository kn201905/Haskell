# Chapter 2. 関数の型

関数に何かを適用させたいときは、関数の後ろに適用させたいものを書きます。<br>
`odd` 関数は「奇数であるかどうかを判定する関数」で、以下のようになります。
```
ghci> odd 3
True

ghci> odd 6
False
```

引数を２つ以上とる関数の場合、引数を並べて書きます。<br>
`compare` 関数は、２つのものの大小関係を判定する関数で、「１つ目のもの」が大きいか小さいかを返します。
```
ghci> compare 2 3
LT  -- LT は小さいという意味

ghci> compare 3 3
EQ  -- EQ は等しいという意味

ghci> compare 3 2
GT  -- GT は大きいという意味
```

以下のような使い方もできます。
```
ghci> (compare 2 3) == LT
True

ghci> compare 4 3 == LT
False
```

Haskell では、「関数に値を適用をする」という操作を多く実行するため、その優先度が最も高くなっています。<br>
そのため、関数に値を適用する場合にかっこを省略して書くことが多く、慣れてないと式の意味を捉え間違えやすいので注意が必要です。

以下の式の結果に注目してください。`max a b` は、大きい方の値を返す関数です。掛け算があると、掛け算を先にしたくなるのですが、`max` への適応が先に実行されることに注意してください。
```
ghci> 2 + max 10 5 * 3 + 4
36
```

上の式は `2 + (max 10 5) * 3 + 4` と同じ意味になります。

## 関数の作成
３つの数を受け取って、その和を **評価値** とする関数は以下のようになります。
```
ghci> f x y z = x + y + z  -- これで f(x,y,z) = x + y + z という関数が定義できます。

ghci> f 2 3 4  -- f(2,3,4) を計算する
9
```

ここで、「評価値」と強調している理由は現段階では伝わりにくいと思います。<br>
Haskell では、`f 2 3 4` というものを見つけたら、それは `2 + 3 + 4` と **置き換える** ものだ、というような考えで処理を進めます。<br>
数学などを通して `=` には、代入という意識が働きやすいですが、Haskell では「代入」ではなく、「置き換え」と考えます。

今、このことを強調してもその理由が分かりにくいと思いますので、今のところは `=` は置き換えなんだな、と思ってもらえばよいです。

> Tips<br>
> C言語などを利用していると、関数を定義し、その関数をコールして、関数からリターンして処理を進める、という気持ちが
> 強いと思います。<br>
> しかし、Haskell では、式の置き換えと簡約によって処理を進めていくので、C言語でいうところのリターンというものはありません。<br>
> `return` という式はありますが、C言語などとまったく異なる意味となっています。<br>
> この根本的な違いが、C言語などを知っている人が Haskell などの関数型言語を理解できない、という原因になっていると思います。<br>
> とりあえず、`=` は代入ではないし、リターンなんかもないんだな、と思いながら気軽に読み進めてもらえばよいお思います。

## if も式
Haskell は関数型言語であり、**値を与えて評価値を算出する** というチェーンで処理を行います。<br>
そのため、結果となる評価値が必ず必要となるため、`if` も式となり、`else` も省略もできません。

```
ghci> f x = if x > 10 then "x is > 10" else "x is <= 10"

ghci> f 8
"x is <= 10"
```


